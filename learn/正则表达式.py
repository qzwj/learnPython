#!/usr/bin/env python3
# -*- coding:utf-8 -*-


# \d 可以匹配一个数字
# \w 可以匹配一个字母或数字
# . 可以匹配任意字符
# * 表示任意个字符(包括0个)
# + 表示至少一个字符
# ? 表示0个或1个字符
# {n}表示n个字符
# {n, m}表示n-m个字符, 不是减,是到
# \s匹配一个空格(包括Tab等空白符) \s+至少一个空格


# 多个组合使用
# \d{3} 匹配3个数字 比如'222'
# \d{3,8} 匹配3-8个数字, 比如'12345'


# 表示范围
# [0-9a-zA-Z\_]可以匹配一个数字,字母或者下划线
# [0-9a-zA-Z\_]+ 可以匹配至少由一个数字,字母或者下划线组成的字符串,比如'a123', '1_s'等
# [a-zA-Z\_][0-9a-zA-Z\_]* 可以匹配由字母或下划线开头, 后接任意个由一个数字,字母或者下划线组成的字符串
# [a-zA-Z\_][0-9a-zA-Z\_]{0, 19} 更精确地限制了变量的长度是1-20个字符(前面的1个+后面的最多19个字符)

# A|B 可以匹配A或者B
# ^表示行的开头 
# ^\d 表示以数字开头
# $表示行的结束
# \d$表示以数字结束
# ^py$ 表示整行匹配,只能匹配'py'


# re模块 
# python中包含所有正则表达式的功能模块
s = 'ABC\\-001' #字符串中\需要转义,下面的方法更好
s = r'ABC\-001'

import re

if re.match(r'^\d{3}\-\d{3,8}$', '010-12345'):
	print('匹配到了') # 返回一个match对象
else:
	print('没有匹配到') #返回None


# 切分字符串
'a b  c'.split(' ') #无法识别连续的空格
s1 = re.split(r'\s+', 'a b   c')
print(s1)
s1 = re.split(r'[\s\,]+', 'a,b c  d')
print(s1)
s1 = re.split(r'[\s\,\;]+', 'a, b;c,d e')
print(s1)


# 分组
m = re.match(r'(\d{3})\-(\d{3,8})$', '010-12345') #()可以分组
print(m.group(0)) #原始字符串
print(m.group(1))
print(m.group(2))


#贪婪匹配
# 最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：
s1 = re.match(r'^(\d+)(0*)$', '102300').groups() #默认贪婪匹配
print(s1)
s1 = re.match(r'^(\d+?)(0*)$', '102300').groups()
print(s1)

#编译
# 当我们在Python中使用正则表达式时，re模块内部会干两件事情：

# 1.编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
# 2.用编译后的正则表达式去匹配字符串。

re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
print(re_telephone.match('010-12345').groups())
print(re_telephone.match('010-8086').groups())

